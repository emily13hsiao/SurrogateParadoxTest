---
title: "Tutorial for main functions in SurrogateParadoxTest package"
output:
  html_document:
---

```{r global_options, echo=FALSE}
knitr::opts_chunk$set(fig.width=7, warning=FALSE, tidy=TRUE, tidy.opts=list(width.cutoff=60))
```
We will go through an example using the main function in the **SurrogateParadoxTest** package. First, install the package from CRAN and load it. 

```{r results = "hide", message=FALSE}
#install.packages("SurrogateParadoxTest")
library(SurrogateParadoxTest)

```

This package provides functions to nonparametrically assess assumptions necessary to prevent the surrogate paradox through hypothesis tests of stochastic dominance, monotonicity of regression functions, and non-negative residual treatment effects. More details will be available in Hsiao, Tian, Parast (2025) "Avoiding the Surrogate Paradox: An Empirical Framework for Assessing Assumptions" (under review).

The main function is **test_assumptions** which tests the 3 assumptions that are sufficient to prevent the surrogate paradox: (1) stochastic dominance of
surrogate values in the treatment group over control group, (2) monotonicity of the relationship 
between surrogate and primary endpoint in both treatment and control group, and (3) non-negative
residual treatment effect of the treatment group over the control group.

The necessary inputs are **s0**, the vector of surrogate marker values in the control group, **s1**, the vector of surrogate marker values in the treated group, **y0**, the vector of primary outcome values in the control group, and **y1**, the vector of primary outcome values in the treated group. Let's make some data, but if you have your own data, use your own data to define objects that will be use for the s0, s1, y0, y1 arguments.

```{r}
#set seed so we get the same result
set.seed(1)
sample.size=100
#generate surrogate marker in control group
s_c <- rnorm(sample.size, 3, 1)
#defining a function of s in the control group
m_c <- function(s) 1 + 1 * s
#generate primary outcome in the control group
y_c <- sapply(s_c, function(s) rnorm(1, m_c(s), 1))

#generate surrogate marker in treated group
s_t <- rnorm(sample.size, 4, 2)
#defining a function of s in the treated group
m_t <- function(s) 2 + 3 * s
#generate primary outcome in the treated group
y_t <- sapply(s_t, function(s) rnorm(1, m_t(s), 1))
```


The default is to run all 3 tests (**type = "all"**). However the user can specify only 1 of the tests by specifying **type = "sd"** for the stochastic dominance assumption, **type = "monotonicity"** for the monotonicity assumption, and **type = "nnr"** for the non-negative residual treatment effect assumption. Note that type = "monotonicity" is computationally intensive and will take time. 

Let's start with just testing stochastic dominance. We will use **all_results=FALSE** which says to only give the result indicating whether the assumption holds or not (omitting all the other details). 

```{r}
test_assumptions(s0 = s_c, y0 = y_t, s1 = s_t, y1 = y_t, type = "sd", all_results = FALSE)

```

Here, the results of the test indicate that the stochastic dominance assumption holds. Now let's ask for all the details. 

```{r}
test_assumptions(s0 = s_c, y0 = y_c, s1 = s_t, y1 = y_t, type = "sd", all_results = TRUE)

```
Truth be told, these won't make sense without seeing the manuscript. But essentially, the null hypothesis of the test is that the stochastic dominance assumption does hold. The alternative is that it is does not hold i.e., there exists some s where dominance does not hold. This gives the value of our test statistic **s_hat**, the p-value from testing this null hypothesis **p.value**, and whether we reject the null hypothesis **reject**. 

Now let's test montonicity; this does involve resampling, so set the seed so your results are reproducible. This function used to be computationally inefficient but we now depend on and use the **MonotoncityTest** package which is much faster. Below, we set the number of bootstrap samples to 200 i.e., **monotonicity_bootstrap_n=200**. 

```{r}
set.seed(12)
test_assumptions(s0 = s_c, y0 = y_c, s1 = s_t, y1 = y_t, type = "monotonicity", all_results = FALSE, monotonicity_bootstrap_n = 200)
```

These results show that the test indicates that the montonicity assumption holds in both groups. 

Now let's test the non-negative residual treatment effect assumption. This also involves boostrap resampling, so set the seed so your results are reproducible. 

```{r}
set.seed(1)
test_assumptions(s0 = s_c, y0 = y_c, s1 = s_t, y1 = y_t, type = "nnr", all_results = FALSE)
```

The test indicates that the non-negative residual treatment effect assumption holds here. 

To test them all, and get all the results, use **type = "all"** or leave unspecified since "all" is the default:

```{r}
set.seed(1)
test_assumptions(s0 = s_c, y0 = y_c, s1 = s_t, y1 = y_t, type = "all", all_results = FALSE, monotonicity_bootstrap_n = 200)
```

The package only exports the **test_assumptions** function. But there are many internal functions you may find useful. To get them, use three colons for example **SurrogateParadoxTest:::smoother_fitter()**. 

That's all for now!

---------